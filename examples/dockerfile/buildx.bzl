"repos for buildx"

load("@aspect_bazel_lib//lib:repo_utils.bzl", "repo_utils")

def _impl_configure_buildx(rctx):
    has_docker = False

    # See if standard docker sock exists
    if not has_docker:
        r = rctx.execute(["stat", "/var/run/docker.sock"])
        if r.return_code == 0:
            has_docker = True

    compatible_with = "[]"
    builder_name = "builder-docker"
    if has_docker:
        # TODO(alex): a less hacky way for a repo rule to find this transitive repo label?
        buildx = rctx.path(Label("@@rules_multitool~~multitool~multitool.{0}//tools/buildx:{0}_executable".format(repo_utils.platform(rctx))))

        r = rctx.execute([buildx, "ls"])
        if not builder_name in r.stdout:
            r = rctx.execute([buildx, "create", "--name", builder_name, "--driver", "docker-container"])
            if r.return_code != 0:
                fail("Failed to create buildx driver %s: \nSTDERR:\n%s\nsSTDOUT:\n%s" % (builder_name, r.stderr, r.stdout))
        else:
            # buildifier: disable=print
            print("WARNING: BuildX driver `%s` already exists." % builder_name)

    else:
        compatible_with = '["@platforms//:incompatible"]'

    rctx.file("defs.bzl", """
# Generated by configure_buildx.bzl
TARGET_COMPATIBLE_WITH = %s
BUILDER_NAME = "%s"
""" % (compatible_with, builder_name))
    rctx.file("BUILD.bazel", 'exports_files(["defs.bzl"])')
    pass

configure_buildx = repository_rule(
    implementation = _impl_configure_buildx,
    local = True,
)
