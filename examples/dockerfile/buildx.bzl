"repos for buildx"

load("@aspect_bazel_lib//lib:repo_utils.bzl", "repo_utils")

def _impl_configure_buildx(rctx):
    has_docker = False

    # See if standard docker sock exists
    if not has_docker:
        r = rctx.execute(["stat", "/var/run/docker.sock"])
        if r.return_code == 0:
            has_docker = True

    compatible_with = "[]"
    builder_name = "builder-docker"
    if has_docker:
        # TODO(alex): a less hacky way for a repo rule to find this transitive repo label?
        if repo_utils.platform(rctx) == "darwin_amd64":
            multitool_label = "@@rules_multitool~~multitool~multitool.macos_x86_64//tools/buildx:macos_x86_64_executable"
        elif repo_utils.platform(rctx) == "darwin_arm64":
            multitool_label = "@@rules_multitool~~multitool~multitool.macos_arm64//tools/buildx:macos_arm64_executable"
        elif repo_utils.platform(rctx) == "linux_amd64":
            multitool_label = "@@rules_multitool~~multitool~multitool.linux_x86_64//tools/buildx:linux_x86_64_executable"
        else:
            fail("platform {} is not known", repo_utils.platform(rctx))

        buildx = rctx.path(Label(multitool_label))

        r = rctx.execute([buildx, "ls"])
        if not builder_name in r.stdout:
            r = rctx.execute([buildx, "create", "--name", builder_name, "--driver", "docker-container"])
            if r.return_code != 0:
                fail("Failed to create buildx driver %s: \nSTDERR:\n%s\nsSTDOUT:\n%s" % (builder_name, r.stderr, r.stdout))
        else:
            # buildifier: disable=print
            print("WARNING: BuildX driver `%s` already exists." % builder_name)

    else:
        compatible_with = '["@platforms//:incompatible"]'

    rctx.file("defs.bzl", """
# Generated by configure_buildx.bzl
TARGET_COMPATIBLE_WITH = %s
BUILDER_NAME = "%s"
""" % (compatible_with, builder_name))
    rctx.file("BUILD.bazel", 'exports_files(["defs.bzl"])')
    pass

configure_buildx = repository_rule(
    implementation = _impl_configure_buildx,
    local = True,
)
